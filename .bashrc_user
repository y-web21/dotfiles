# shellcheck disable=SC2148
#
# ShellCheck ignore list:
#  - SC2148: Can't follow non-constant source. Use a directive to specify location.

test -f ~/dotfiles/private_settings/pre.bash && source ~/dotfiles/private_settings/pre.bash

COMMON_RC=$HOME/.commonrc

if [ -e $COMMON_RC ]
then source $COMMON_RC
fi

# ==================== ~/.local ====================
# putting completion files in ~/.local/share/bash-completion/completions/ should 100% work on modern Linux systems.
__BASH_COMPLETION_USER_DIR__="${HOME}/.local/share/bash-completion/completions"
if [ ! -d ${__BASH_COMPLETION_USER_DIR__} ]; then
  if apt list --installed 2>/dev/null | grep bash-completion >/dev/null 2>&1 ;then
    mkdir -p ${__BASH_COMPLETION_USER_DIR__}
  fi
fi
unset __BASH_COMPLETION_USER_DIR__

metapack(){
  if apt-get -v >/dev/null 2>&1; then
    echo '=== apt list, apt-get install ==='
    # sudo apt update
    dpkg -l "*${1}*" | grep --color "${1}"
    # apt list "*${1}*" | grep --color "${1}"
  fi

  if yum -v >/dev/null 2>&1; then
    echo -e '\n=== yum search, yum install ==='
    yum search "${1}" | grep --color "${1}"
  fi

  if dnf -v >/dev/null 2>&1; then
    echo -e '\n=== dnf search, dnf install ==='
    dnf search "${1}" | grep --color "${1}"
  fi

  if nix --version >/dev/null 2>&1; then
    echo -e '\n=== nix-env -qa, nix-env --install ==='
    nix-env --query --available"${1}" | grep --color "${1}"
  fi

  if brew -v >/dev/null 2>&1; then
    echo -e '\n=== brew search, brew install ==='
    brew search "${1}" | grep --color "${1}"
  fi

  if scoop -v >/dev/null 2>&1; then
    echo -e '\n=== scoop search, scoop install ==='
    scoop search "${1}" | grep --color "${1}"
  fi
}


cs-bin(){
  cat <<-'EOL'
	# x byte output
	xxd -g1 cha
	od -tx1 cha
	od -tc cha
	od -tx1 -tc -An <(echo -n abcd)
	od -tx1 -tc -An <(echo ABCD)
	# file header
	xxd -l 50 bash_function.png
	xxd -l 50 asdf.jpg
	xxd -l 300 sample.wav
	od -tc -N 50 return_code.txt
	EOL
}

cs-rsync(){
  cat <<-'EOL'
	# the fllowing example, copy xml file and directories. (on ubuntu rsync)
	rsync -r --include='*/' --include='*.xml' --exclude='*' src dst

	# シンボリックリンクを実体として、.tmpと.db以外コピー の条件でテストラン
	 rsync -ahvL --include='*/' --exclude='*.db' --exclude='*.tmp' src/ dst --dry-run

	-a -rlptgoDを指定することでなるべくコピー元のファイルと同一条件でコピーする。
	-h human readable unit
	-v verbose
	--progress ファイル単位での状況表示
	-n --dry-run
	-l シンボリックリンクをシンボリックリンクのままコピー
	-L シンボリックリンクを実体としてコピー
	--max-size 転送対象のファイルサイズの上限
	-e sshのポート指定。ex. rsync -e "ssh -p 22222"
	EOL
}

# alias lanana='curl -sS https://www.lanana.org/lsbreg/providers/providers.txt | grep -vE '\''^\s'\'' | grep -v '\''^\s*$'\'' | awk '\''{print $1}'\'''
lanana() {
  # The Linux Assigned Names And Numbers Authority
  # Linux Standard Base (LSB)
  local URL LIST HZLINE
  case "$1" in
  providers)
    # LSB Provider Names - LSB Provider Name Registry
    URL=https://www.lanana.org/lsbreg/providers/providers.txt
    ;;
  packages)
    # LSB Package Names - LSB Package Name Registry
    URL=https://www.lanana.org/lsbreg/packages/packages.txt
    ;;
  init-script)
    # LSB Init Script Names - LSB Init Script Name Registry
    URL=https://www.lanana.org/lsbreg/init/init.txt
    ;;
  cron-script)
    # LSB Cron Script Names - LSB Cron Script Name Registry
    URL=https://www.lanana.org/lsbreg/packages/packages.txt
    ;;
  *)
    echo 'invalid arg error'
    return 1
    ;;
  esac

  LIST=$(curl -sS ${URL}) | grep -vE '^\s' | grep -v '^\s*$' | awk '{print $1}'
  HZLINE=$(curl -sS ${URL} | grep -nE '^-+' | cut -d':' -f1)
  curl -sS ${URL} | grep -vE '^\s' | grep -v '^\s*$' | awk "NR>${HZLINE}{print \$1}"
}

_lanana_comp() {
  local cur complist
  _get_comp_words_by_ref -n : cur
  complist="providers packages init-script cron-script"
  COMPREPLY=($(compgen -W "${complist}" -- "${cur}"))
} && complete -F _lanana_comp lanana

function git-get-short-hash {
  # shift
  # local dst=${2:-\~}
  # \$2 = destination(guest) default : ${dst}
  if [[ $# -gt 0 ]]; then
    git log --oneline | head -${1} | tail -1 | awk '{print $1}'
  else
    cat <<-EOF
		1 args required.
		\$1 = line (git log --oneline)
		EOF
  fi
}

function git-get-hash {
  if [[ $# -gt 0 ]]; then
    git log --pretty=oneline | head -${1} | tail -1 | awk '{print $1}'
  else
    cat <<-EOF
		1 args required.
		\$1 = line (git log --oneline)
		EOF
  fi
}

function git-parent-branch {
  if [[ $# -gt 1 ]]; then
    git show-branch --sha1-name $1 $2 | tail -1
  else
    cat <<-EOF
		2 args required.
		\$1 = branch
		\$2 = branch
		EOF
  fi
}

git-config-options-helpo(){
  cat <<-EOF
	git config core.xxx --local yyy

	# ignore case はPHPでは困るなぁ
	ignorecase = <default:true>

	# prevent changes to perimission 644 when push from windows
	filemode = <default:true>

	# lf に固定 (主に for windows)
  git config --global core.autocrlf input
  # それよりも false で git側に改行コード変換するコントロールを渡さない方がいいと思った。
  git config --global core.autocrlf false (linux default)

	# Win向けの改行コードをリポジトリに保持する場合
	add .gitattributes > echo '*.html diff=sjis' > .gitattributes

	EOF
}

# git completion
_BASH_COMPLETION_DIR="/etc/bash_completion.d"
# _BASH_COMPLETION_DIR="${HOME}/.local/share/bash-completion/completions"
# _BASH_COMPLETION_DIR="/usr/share/bash-completion/completions/"
# source /etc/bash_completion.d/git
# source /usr/share/bash-completion/completions/git
# source /etc/bash_completion.d/git-completion.bash

if [[ -d /etc/bash_completion.d ]]; then
  [[ ! -d ${_BASH_COMPLETION_DIR} ]] && mkdir -p ${_BASH_COMPLETION_DIR}
  if [[ ! -f ${_BASH_COMPLETION_DIR}/git-prompt ]]; then
    curl -sS https://raw.githubusercontent.com/git/git/master/contrib/completion/git-prompt.sh -o ~/git-prompt &&
      sudo mv ~/git-prompt.sh ${_BASH_COMPLETION_DIR}/
  fi

  if [[ ! -f ${_BASH_COMPLETION_DIR}/git-completion.bash ]]; then
    curl -sS https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash -o ~/git-completion.bash &&
      sudo mv ~/git-completion.bash ${_BASH_COMPLETION_DIR}/ &&
      cat <<-EOF >>${_BASH_COMPLETION_DIR}/git-completion.bash
			__git_complete g __git_main
			__git_complete ga _git_add
			__git_complete gb _git_branch
			__git_complete gc _git_checkout
			__git_complete gcm _git_commit
			__git_complete gd _git_diff
			__git_complete gl _git_log
			__git_complete gs _git_status
			__git_complete gsh _git_stash
		EOF
  fi
  alias g="git"
  alias ga="git add"
  alias gb="git branch"
  alias gc="git checkout"
  alias gcm="git commit"
  alias gd="git diff"
  alias gl="git log"
  alias gs="git status"
  alias gsh="git stash"

  # if type __git_ps1 > /dev/null 2>&1; then
  # __git_ps1 プロンプトに各種情報を表示
  GIT_PS1_SHOWDIRTYSTATE=1     # ファイル変更 unstaged *, staged +
  GIT_PS1_SHOWUPSTREAM=auto    # HEADとupstreamとの差分 =, <, >, <>(branch)
  GIT_PS1_SHOWUNTRACKEDFILES=1 # 新規ファイル untracked files %
  GIT_PS1_SHOWSTASHSTATE=1     # スタッシュあり $
  GIT_PS1_SHOWCOLORHINTS=1     # 表示内容のカラー化
  # upstream = remote tracking branch のこと
fi
unset _BASH_COMPLETION_DIR

# ============== .bashrc =================
# /etc/skel/.bashrc

if is_wsl; then
  test -r ~/.bashrc_wsl && . ~/.bashrc_wsl
elif is_linux; then
  test -r ~/.bashrc_linux && . ~/.bashrc_linux
elif is_mac; then
  :
else
  echo 'nomatch'
fi

# shellcheck disable=1090
test -r ~/.bash_aliases && . ~/.bash_aliases
# shellcheck disable=1090
test -r ~/.bashrc.local && . ~/.bashrc.local

# shellcheck disable=1090
. ~/dotfiles/modules/keybind.bash
# shellcheck disable=1090
. ~/dotfiles/functions/primary.bash

# shellcheck disable=1090
test -f ~/dotfiles/private_settings/post.bash && source ~/dotfiles/private_settings/post.bash

if is_debian_based;then
  apt moo
  # sudo apt list --upgradable
  # sudo apt install --only-upgrade
  # apt-mark hold
  # apt-mark unhold
  # APT_HOLD_LIST=$(dpkg --get-selections | grep hold)
fi

