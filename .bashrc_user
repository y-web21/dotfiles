test -f ~/dotfiles/private_settings/pre.bash && source ~/dotfiles/private_settings/pre.bash

COMMON_RC=$HOME/.commonrc

if [ -e $COMMON_RC ]
then source $COMMON_RC
fi

# ==================== ~/.local ====================
# putting completion files in ~/.local/share/bash-completion/completions/ should 100% work on modern Linux systems.
__BASH_COMPLETION_USER_DIR__="${HOME}/.local/share/bash-completion/completions"
if [ ! -d ${__BASH_COMPLETION_USER_DIR__} ]; then
  if apt list --installed 2>/dev/null | grep bash-completion >/dev/null 2>&1 ;then
    mkdir -p ${__BASH_COMPLETION_USER_DIR__}
  fi
fi
unset __BASH_COMPLETION_USER_DIR__

# ============= function ==============
# function source_file {
#   if [ $# -lt 1 ];then
#     echo "ERROR!!! source_file is called w/o an argument"
#     return
#   fi
#   arg="$1"
#   shift
#   if [ -r "$arg" ]; then
#     source "$arg"
#   fi
# }

ucase() { echo ${@^^}; }
lcase() { echo ${@,,}; }
mkcd() { mkdir -p $1; cd $1; }
make-bak() { test $# -ne 0 && cp ${1}{,.bak}; }
__rm__() {
  # 眠いのでまた今度な
  if [[ $(grep -E '-(rf|fr)[ ]{1,}\/[ ]{1,}|-[rf]{}[ ]{1,}-[rf]\/[ ]{1,}') ]]; then
    echo damepo
  fi
  rm $*
}

metapack(){
  if apt-get -v >/dev/null 2>&1; then
    echo '=== apt list, apt-get install ==='
    dpkg -l "*${1}*" | grep --color "${1}"
    # apt list "*${1}*" | grep --color "${1}"
  fi

  if yum -v >/dev/null 2>&1; then
    echo -e '\n=== yum search, yum install ==='
    yum search "${1}" | grep --color "${1}"
  fi

  if dnf -v >/dev/null 2>&1; then
    echo -e '\n=== dnf search, dnf install ==='
    dnf search "${1}" | grep --color "${1}"
  fi

  if nix --version >/dev/null 2>&1; then
    echo -e '\n=== nix-env -qa, nix-env --install ==='
    nix-env --query --available"${1}" | grep --color "${1}"
  fi

  if brew -v >/dev/null 2>&1; then
    echo -e '\n=== brew search, brew install ==='
    brew search "${1}" | grep --color "${1}"
  fi

  if scoop -v >/dev/null 2>&1; then
    echo -e '\n=== scoop search, scoop install ==='
    scoop search "${1}" | grep --color "${1}"
  fi
}

apt-remove-purge(){
  sudo apt-get -y remove $1
  sudo apt-get -y remove --auto-remove $1
  sudo apt-get -y purge $1
  sudo apt-get -y purge --auto-remove $1
}

version(){
  echo '- OS'
  echo cat /etc/os-release | grep PRETTY_NAME | sed -e 's/PRETTY_NAME=//' | sed 's/"//g'
  docker --version 2>/dev/null
  docker-compose --version 2>/dev/null
  nginx -v 2>/dev/null
}


rsync-helpo(){
  cat <<-'EOL'
	# the fllowing example, copy xml file and directories. (on ubuntu rsync)
	rsync -r --include='*/' --include='*.xml' --exclude='*' src dst

	# シンボリックリンクを実体として、.tmpと.db以外コピー の条件でテストラン
	 rsync -ahvL --include='*/' --exclude='*.db' --exclude='*.tmp' src/ dst --dry-run

	-a -rlptgoDを指定することでなるべくコピー元のファイルと同一条件でコピーする。
	-h human readable unit
	-v verbose
	--progress ファイル単位での状況表示
	-n --dry-run
	-l シンボリックリンクをシンボリックリンクのままコピー
	-L シンボリックリンクを実体としてコピー
	--max-size 転送対象のファイルサイズの上限
	-e sshのポート指定。ex. rsync -e "ssh -p 22222"
	EOL
}

# alias lanana='curl -sS https://www.lanana.org/lsbreg/providers/providers.txt | grep -vE '\''^\s'\'' | grep -v '\''^\s*$'\'' | awk '\''{print $1}'\'''
lanana() {
  # The Linux Assigned Names And Numbers Authority
  # Linux Standard Base (LSB)
  local URL LIST HZLINE
  case "$1" in
  providers)
    # LSB Provider Names - LSB Provider Name Registry
    URL=https://www.lanana.org/lsbreg/providers/providers.txt
    ;;
  packages)
    # LSB Package Names - LSB Package Name Registry
    URL=https://www.lanana.org/lsbreg/packages/packages.txt
    ;;
  init-script)
    # LSB Init Script Names - LSB Init Script Name Registry
    URL=https://www.lanana.org/lsbreg/init/init.txt
    ;;
  cron-script)
    # LSB Cron Script Names - LSB Cron Script Name Registry
    URL=https://www.lanana.org/lsbreg/packages/packages.txt
    ;;
  *)
    echo 'invalid arg error'
    return 1
    ;;
  esac

  LIST=$(curl -sS ${URL}) | grep -vE '^\s' | grep -v '^\s*$' | awk '{print $1}'
  HZLINE=$(curl -sS ${URL} | grep -nE '^-+' | cut -d':' -f1)
  curl -sS ${URL} | grep -vE '^\s' | grep -v '^\s*$' | awk "NR>${HZLINE}{print \$1}"
}

_lanana_comp() {
  local cur complist
  _get_comp_words_by_ref -n : cur
  complist="providers packages init-script cron-script"
  COMPREPLY=($(compgen -W "${complist}" -- "${cur}"))
} && complete -F _lanana_comp lanana

function git-get-short-hash {
  # shift
  # local dst=${2:-\~}
  # \$2 = destination(guest) default : ${dst}
  if [[ $# -gt 0 ]]; then
    git log --oneline | head -${1} | tail -1 | awk '{print $1}'
  else
    cat <<-EOF
		1 args required.
		\$1 = line (git log --oneline)
		EOF
  fi
}

function git-get-hash {
  if [[ $# -gt 0 ]]; then
    git log --pretty=oneline | head -${1} | tail -1 | awk '{print $1}'
  else
    cat <<-EOF
		1 args required.
		\$1 = line (git log --oneline)
		EOF
  fi
}

function git-parent-branch {
  if [[ $# -gt 1 ]]; then
    git show-branch --sha1-name $1 $2 | tail -1
  else
    cat <<-EOF
		2 args required.
		\$1 = branch
		\$2 = branch
		EOF
  fi
}

git-config-options-helpo(){
  cat <<-EOF
	git config core.xxx --local yyy

	# ignore case はPHPでは困るなぁ
	ignorecase = <default:true>

	# prevent changes to perimission 644 when push from windows
	filemode = <default:true>

	# lf に固定 (主に for windows)
  git config --global core.autocrlf input
  # それよりも false で git側に改行コード変換するコントロールを渡さない方がいいと思った。
  git config --global core.autocrlf false (linux default)

	# Win向けの改行コードをリポジトリに保持する場合
	add .gitattributes > echo '*.html diff=sjis' > .gitattributes

	EOF
}

function grepsjis-recursive {
  # grep -$1 "${2}" --include="${3}" --include="${4}" | xargs -I% iconv -f cp932 -t UTF8 '%' | grep --color "${2}"
  grep $1 -l $3 . $4 $5 $6 | xargs -I% iconv -f cp932 -t UTF8 '%' | grep $1 $2 --color $3
}

# docker
function dockerhub-tags() {
  if [[ $# -lt 1 ]]; then
		cat <<- 'EOL'
			$1 = image name (ex. node, python, php...)
			$2 = inquery pages (default 3 pages)
		EOL
    return 1
  fi
  local MAX_PAGE=${2:-3}
  local IMAGE=$1
  local BASE_URL='https://registry.hub.docker.com/v2/repositories/library/'
  local NEXT_URL=${BASE_URL}${IMAGE}/tags
  for _ in $(seq 1 $MAX_PAGE); do
    curl -sS ${NEXT_URL} | jq -r '."results"[]["name"]'
    NEXT_URL=$(curl -sS ${NEXT_URL} | jq -r '."next"')
    [ ${NEXT_URL} == "null" ] || [ ${NEXT_URL} == "" ] && break
  done
}

function rand-str() {
  local len=${1:-16}
  local line=${2:-1}
  local tr_arg=${3:-a-zA-Z0-9}
  local prepare=$(($len + 100))
  cat /dev/urandom | tr -dc ${tr_arg} | fold -w ${len} | head -n ${prepare} | uniq | head -n ${line}
}

google() {
  if [ $(echo $1 | grep "^-[cfs]$") ]; then
    local opt=$1
    shift
  fi
  local url="https://google.com/search?q=${*// /+}"
  local c="Google Chrome"
  local f="Firefox"
  local s="Safari"
  case $opt in
  -c) open $url -a $c ;;
  -f) open $url -a $f ;;
  -s) open $url -a $s ;;
  *) open $url ;;
  esac
}

# git completion
_BASH_COMPLETION_DIR="/etc/bash_completion.d"
# _BASH_COMPLETION_DIR="${HOME}/.local/share/bash-completion/completions"
# _BASH_COMPLETION_DIR="/usr/share/bash-completion/completions/"

if [[ -d /etc/bash_completion.d ]]; then
  [[ ! -d ${_BASH_COMPLETION_DIR} ]] && mkdir -p ${_BASH_COMPLETION_DIR}
  if [[ ! -f ${_BASH_COMPLETION_DIR}/git-prompt ]]; then
    curl -sS https://raw.githubusercontent.com/git/git/master/contrib/completion/git-prompt.sh -o ~/git-prompt &&
      sudo mv ~/git-prompt.sh ${_BASH_COMPLETION_DIR}/
  fi

  if [[ ! -f ${_BASH_COMPLETION_DIR}/git-completion.bash ]]; then
    curl -sS https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash -o ~/git-completion.bash &&
      sudo mv ~/git-completion.bash ${_BASH_COMPLETION_DIR}/ &&
      cat <<-EOF >>${_BASH_COMPLETION_DIR}/git-completion.bash
			__git_complete g __git_main
			__git_complete ga _git_add
			__git_complete gb _git_branch
			__git_complete gc _git_checkout
			__git_complete gcm _git_commit
			__git_complete gd _git_diff
			__git_complete gl _git_log
			__git_complete gs _git_status
			__git_complete gsh _git_stash
		EOF
  fi
  alias g="git"
  alias ga="git add"
  alias gb="git branch"
  alias gc="git checkout"
  alias gcm="git commit"
  alias gd="git diff"
  alias gl="git log"
  alias gs="git status"
  alias gsh="git stash"

  # if type __git_ps1 > /dev/null 2>&1; then
  # __git_ps1 プロンプトに各種情報を表示
  GIT_PS1_SHOWDIRTYSTATE=1     # ファイル変更 unstaged *, staged +
  GIT_PS1_SHOWUPSTREAM=auto    # HEADとupstreamとの差分 =, <, >, <>(branch)
  GIT_PS1_SHOWUNTRACKEDFILES=1 # 新規ファイル untracked files %
  GIT_PS1_SHOWSTASHSTATE=1     # スタッシュあり $
  GIT_PS1_SHOWCOLORHINTS=1     # 表示内容のカラー化
  # upstream = remote tracking branch のこと
fi
unset _BASH_COMPLETION_DIR

# installation.bash 用へ移行予定の者たち =================================
# /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# curl -LI https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash -o /dev/null -w '%{http_code}'

enable-git-completion() {
  GIT_COMPLETION_PATH=$(find ~ -name git-completion.bash 2>/dev/null | head -1)
  # echo $GIT_COMPLETION_PATH
  if [ ${#GIT_COMPLETION_PATH} -eq 0 ]; then
    local gitcomp_url='https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash'
    local hcode=$(curl -LIsS ${gitcomp_url} | grep ^HTTP | awk '{print $2}')

    if [[ hcode -ne 200 ]]; then
      echo '!!!! failed to include git-completion !!!!!'
      return
    fi
    GIT_COMPLETION_PATH="${HOME}/git-completion.bash"
    curl -sS ${gitcomp_url} >$GIT_COMPLETION_PATH
  fi
  source ${GIT_COMPLETION_PATH}
}

# イラネーな
# enable-git-completion

install-manpages-ja() {
  read -p 'change locale to JP, ok? (y)' input
  test "$input" != "y" && return 1

  # by JM Project
  sudo apt update
  sudo apt install manpages-ja
  sudo apt install manpages-ja-dev
  sudo apt install language-pack-ja
  sudo update-locale LANG=ja_JP.utf8
  locale
  sleep 4
  exec $SHELL -l
  # export LC_ALL=ja_JP.utf8
  # export LANGUAGE=ja_JP.utf8
}

install-docker-compose-v1() {
  sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
  sudo chmod +x /usr/local/bin/docker-compose
  # add completion file
  sudo curl \
    -L https://raw.githubusercontent.com/docker/compose/1.29.2/contrib/completion/bash/docker-compose \
    -o /etc/bash_completion.d/docker-compose
}

install-docker-compose-v2() {
  sudo apt-get update
  sudo apt-get install \
    ca-certificates \
    curl \
    gnupg \
    lsb-release
  sudo mkdir -p /etc/apt/keyrings
  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
  echo \
    "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
    $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list >/dev/null
  sudo apt-get update
  sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin
}

install-awscliv2() {
  if [ "$(which unzip)" = '' ]; then
    test -f /etc/redhat-release/ && sudo dnf install -y unzip
    test -f /etc/system-release/ && sudo yum install -y unzip
    test -f /etc/debian-release/ && sudo apt install -y unzip
  fi

  curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
  unzip awscliv2.zip
  sudo ./aws/install
  rm awscliv2.zip && rm -rf aws/
  aws --version
  # aws cli v2 completion
}

test -f '/usr/local/bin/aws_completer' && complete -C '/usr/local/bin/aws_completer' aws

# ============================================================

# read -p "Hit enter: "
setup-awscliv2() {
  csv=${1:-credentials.csv}

  while :; do
    read -p "import csv? ([y/n/[a]bort): " key
    case "$key" in
    [aA]*)
      echo 'abort.'
      break
      ;;
    [yY] | [yY]es)
      # credentials accessKey csv でのIAMユーザー追加
      aws configure set region ap-northeast-1
      aws configure import --csv file://${csv}
      break
      ;;
    [nN]*)
      # 手動セットアップ
      aws configure set region ap-northeast-1
      aws configure
      # リージョン情報セット ~/.aws/config に保存
      break
      ;;
    *) ;;
    esac
  done
  echo 'set following env...'
  echo 'export AWS_PROFILE=<your profile name>'
  echo 'export AWS_DEFAULT_REGION=<region  ex. ap-northeast-1>'
}

if is_wsl; then
  test -r ~/.bashrc_wsl && . ~/.bashrc_wsl
elif is_linux; then
  test -r ~/.bashrc_linux && . ~/.bashrc_linux
elif is_mac; then
  :
else
  echo 'nomatch'
fi

# ============= PS1 sample ===============
# if [ -f /etc/bash_completion.d/git-prompt.sh ];then
#     PS1='\e[30;47m \t \e[30;44m\e[30;37m \W $(__git_ps1 "\e[30;47m(%s)")\e[39;49m <`git config user.name`> \e[0m\n\$ '
# else
#     PS1='\e[30;47m \t \e[30;44m\e[30;37m \W \e[0m we need git! \n\$ '
# fi

# ============= to .bashrc ===============
# test -r ~/.bashrc_user && . ~/.bashrc_user

test -r ~/.bash_aliases && . ~/.bash_aliases
test -r ~/.bashrc.local && . ~/.bashrc.local

if is_debian_based;then
  apt moo
  # sudo apt list --upgradable
  # sudo apt install --only-upgrade
  # apt-mark hold
  # apt-mark unhold
  # APT_HOLD_LIST=$(dpkg --get-selections | grep hold)
fi

test -f ~/dotfiles/private_settings/post.bash && source ~/dotfiles/private_settings/post.bash

f(){
  touch "$1" 2>/dev/null || mkdir -p "${1%/*}" && touch "${1}"
}
