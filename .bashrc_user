#!/usr/bin/env bash

# enable i-search. (disable terminal stop)
if [[ -t 0 ]]; then
  stty stop undef
  # stty start undef
fi

# base type
is_debian_based() { [ -f /etc/debian_version ]; }
is_redhat_based() { [ -f /etc/redhat-release ]; }
is_slackware_based() { :; }
# os
is_centos() { [ "$(cat /etc/redhat-release | cut -d' ' -f1 2>/dev/null)" == 'CentOS' ]; }
is_linux() { [ "$(expr substr $(uname -s) 1 5)" == 'Linux' ]; }
is_mac() { [ "$(uname)" == 'Darwin' ]; }
is_ubuntu() { grep '^NAME="Ubuntu' /etc/os-release >/dev/null 2>&1; }
is_wsl() { [ -n "$(which wslpath 2>/dev/null)" ]; } # type2
is_wsl() { [ -f /proc/sys/fs/binfmt_misc/WSLInterop ]; }

# =========== ENV, VAR ===========
export LESSCHARSET=utf-8
# color syntax less
export LESS='-iRXS'
# sudo apt install source-highlight
shpath="/usr/share/source-highlight/src-hilite-lesspipe.sh"
if [[ -f ${shpath} ]]; then
  export LESSOPEN="| ${shpath} %s"
fi
unset shpath

# ==================== ~/.local ====================
# putting completion files in ~/.local/share/bash-completion/completions/ should 100% work on modern Linux systems.
__BASH_COMPLETION_USER_DIR__="${HOME}/.local/share/bash-completion/completions"
if [ ! -d ${__BASH_COMPLETION_USER_DIR__} ]; then
  if apt list --installed 2>/dev/null | grep bash-completion >/dev/null 2>&1 ;then
    mkdir -p ${__BASH_COMPLETION_USER_DIR__}
  fi
fi
unset __BASH_COMPLETION_USER_DIR__

# ============= function ==============
# function source_file {
#   if [ $# -lt 1 ];then
#     echo "ERROR!!! source_file is called w/o an argument"
#     return
#   fi
#   arg="$1"
#   shift
#   if [ -r "$arg" ]; then
#     source "$arg"
#   fi
# }

ucase() { echo ${@^^}; }
lcase() { echo ${@,,}; }
mkcd() { mkdir -p $1; cd $1; }
make-bak() { test $# -ne 0 && cp ${1}{,.bak}; }
__rm__() {
  # 眠いのでまた今度な
  if [[ $(grep -E '-(rf|fr)[ ]{1,}\/[ ]{1,}|-[rf]{}[ ]{1,}-[rf]\/[ ]{1,}') ]]; then
    echo damepo
  fi
  rm $*
}

metapack(){
  if [[ $(apt 2>/dev/null) ]];then
    apt search --names-only $1
  fi
  if [[ $(brew -v 2>/dev/null) ]];then
    brew search $1
  fi
}

# memo
port_listen(){
  sudo lsof -i -P -n
}

rsync-helpo(){
  cat <<-'EOL'
	# the fllowing example, copy xml file and directories. (on ubuntu rsync)
	rsync -r --include='*/' --include='*.xml' --exclude='*' src dst

	# シンボリックリンクを実体として、.tmpと.db以外コピー の条件でテストラン
	 rsync -ahvL --include='*/' --exclude='*.db' --exclude='*.tmp' src/ dst --dry-run

	-a -rlptgoDを指定することでなるべくコピー元のファイルと同一条件でコピーする。
	-h human readable unit
	-v verbose
	--progress ファイル単位での状況表示
	-n --dry-run
	-l シンボリックリンクをシンボリックリンクのままコピー
	-L シンボリックリンクを実体としてコピー
	--max-size 転送対象のファイルサイズの上限
	-e sshのポート指定。ex. rsync -e "ssh -p 22222"
	EOL
}

# alias lanana='curl -sS https://www.lanana.org/lsbreg/providers/providers.txt | grep -vE '\''^\s'\'' | grep -v '\''^\s*$'\'' | awk '\''{print $1}'\'''
lanana() {
  # The Linux Assigned Names And Numbers Authority
  # Linux Standard Base (LSB)
  local URL LIST HZLINE
  case "$1" in
  providers)
    # LSB Provider Names - LSB Provider Name Registry
    URL=https://www.lanana.org/lsbreg/providers/providers.txt
    ;;
  packages)
    # LSB Package Names - LSB Package Name Registry
    URL=https://www.lanana.org/lsbreg/packages/packages.txt
    ;;
  init-script)
    # LSB Init Script Names - LSB Init Script Name Registry
    URL=https://www.lanana.org/lsbreg/init/init.txt
    ;;
  cron-script)
    # LSB Cron Script Names - LSB Cron Script Name Registry
    URL=https://www.lanana.org/lsbreg/packages/packages.txt
    ;;
  *)
    echo 'invalid arg error'
    return 1
    ;;
  esac

  LIST=$(curl -sS ${URL}) | grep -vE '^\s' | grep -v '^\s*$' | awk '{print $1}'
  HZLINE=$(curl -sS ${URL} | grep -nE '^-+' | cut -d':' -f1)
  curl -sS ${URL} | grep -vE '^\s' | grep -v '^\s*$' | awk "NR>${HZLINE}{print \$1}"
}

_lanana_comp() {
  local cur complist
  _get_comp_words_by_ref -n : cur
  complist="providers packages init-script cron-script"
  COMPREPLY=($(compgen -W "${complist}" -- "${cur}"))
} && complete -F _lanana_comp lanana

function git-get-short-hash {
  # shift
  # local dst=${2:-\~}
  # \$2 = destination(guest) default : ${dst}
  if [[ $# > 0 ]]; then
    git log --oneline | head -${1} | tail -1 | awk '{print $1}'
  else
    cat <<-EOF
		1 args required.
		\$1 = line (git log --oneline)
		EOF
  fi
}

function git-get-hash {
  if [[ $# > 0 ]]; then
    git log --pretty=oneline | head -${1} | tail -1 | awk '{print $1}'
  else
    cat <<-EOF
		1 args required.
		\$1 = line (git log --oneline)
		EOF
  fi
}

function git-parent-branch {
  if [[ $# > 1 ]]; then
    git show-branch --sha1-name $1 $2 | tail -1
  else
    cat <<-EOF
		2 args required.
		\$1 = branch
		\$2 = branch
		EOF
  fi
}

git-config-options-helpo(){
    cat <<-EOF
	git config core.xxx --local yyy

	# ignore case はPHPでは困るなぁ
	ignorecase = <default:true>

	# prevent changes to perimission 644 when push from windows
	filemode = <default:true>

	# lf に固定 (主に for windows)
  git config --global core.autocrlf input
  # それよりも false で git側に改行コード変換するコントロールを渡さない方がいいと思った。
  git config --global core.autocrlf false (linux default)

	# Win向けの改行コードをリポジトリに保持する場合
	add .gitattributes > echo '*.html diff=sjis' > .gitattributes

	EOF
}

function grepsjis-recursive {
  # grep -$1 "${2}" --include="${3}" --include="${4}" | xargs -I% iconv -f cp932 -t UTF8 '%' | grep --color "${2}"
  grep $1 -l $3 . $4 $5 $6 | xargs -I% iconv -f cp932 -t UTF8 '%' | grep $1 $2 --color $3
}

# docker
function dockerhub-tags() {
  if [[ $# < 1 ]]; then
    echo '$1 = image name (ex. node, python, php...)'
    return 1
  fi
  local IMAGE=$1
  curl -sS https://registry.hub.docker.com/v1/repositories/${IMAGE}/tags | sed "s/,/\n/g" | cut -d'"' -f4 | awk 'NF'
}

function rand-str() {
  local len=${1:-16}
  local line=${2:-1}
  local tr_arg=${3:-a-zA-Z0-9}
  local prepare=$(($len + 100))
  cat /dev/urandom | tr -dc ${tr_arg} | fold -w ${len} | head -n ${prepare} | uniq | head -n ${line}
}

google() {
  if [ $(echo $1 | grep "^-[cfs]$") ]; then
    local opt=$1
    shift
  fi
  local url="https://google.co.jp/search?q=${*// /+}"
  local c="Google Chrome"
  local f="Firefox"
  local s="Safari"
  case $opt in
  -c) open $url -a $c ;;
  -f) open $url -a $f ;;
  -s) open $url -a $s ;;
  *) open $url ;;
  esac
}

# git completion
_BASH_COMPLETION_DIR="/etc/bash_completion.d"
# _BASH_COMPLETION_DIR="${HOME}/.local/share/bash-completion/completions"
# _BASH_COMPLETION_DIR="/usr/share/bash-completion/completions/"

if [[ -d /etc/bash_completion.d ]]; then
  [[ ! -d ${_BASH_COMPLETION_DIR} ]] && mkdir -p ${_BASH_COMPLETION_DIR}
  if [[ ! -f ${_BASH_COMPLETION_DIR}/git-prompt ]]; then
    curl -sS https://raw.githubusercontent.com/git/git/master/contrib/completion/git-prompt.sh -o ~/git-prompt &&
      sudo mv ~/git-prompt.sh ${_BASH_COMPLETION_DIR}/
  fi
  if [[ ! -f ${_BASH_COMPLETION_DIR}/git-completion.bash ]]; then
    curl -sS https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash -o ~/git-completion.bash &&
      sudo mv ~/git-completion.bash ${_BASH_COMPLETION_DIR}/ &&
      cat <<-EOF >>${_BASH_COMPLETION_DIR}/git-completion.bash
			__git_complete g __git_main
			__git_complete ga _git_add
			__git_complete gb _git_branch
			__git_complete gc _git_checkout
			__git_complete gcm _git_commit
			__git_complete gd _git_diff
			__git_complete gl _git_log
			__git_complete gs _git_status
			__git_complete gsh _git_stash
		EOF
  fi
  alias g="git"
  alias ga="git add"
  alias gb="git branch"
  alias gc="git checkout"
  alias gcm="git commit"
  alias gd="git diff"
  alias gl="git log"
  alias gs="git status"
  alias gsh="git stash"

  # if type __git_ps1 > /dev/null 2>&1; then
  # __git_ps1 プロンプトに各種情報を表示
  GIT_PS1_SHOWDIRTYSTATE=1     # ファイル変更 unstaged *, staged +
  GIT_PS1_SHOWUPSTREAM=auto    # HEADとupstreamとの差分 =, <, >, <>(branch)
  GIT_PS1_SHOWUNTRACKEDFILES=1 # 新規ファイル untracked files %
  GIT_PS1_SHOWSTASHSTATE=1     # スタッシュあり $
  GIT_PS1_SHOWCOLORHINTS=1     # 表示内容のカラー化
  # upstream = remote tracking branch のこと
fi
unset _BASH_COMPLETION_DIR

# instalation.bash 用へ移行予定の者たち =================================
# /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# curl -LI https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash -o /dev/null -w '%{http_code}'

enable-git-completion() {
  GIT_COMPLETION_PATH=$(find ~ -name git-completion.bash 2>/dev/null | head -1)
  # echo $GIT_COMPLETION_PATH
  if [ ${#GIT_COMPLETION_PATH} -eq 0 ]; then
    local gitcomp_url='https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash'
    local hcode=$(curl -LIsS ${gitcomp_url} | grep ^HTTP | awk '{print $2}')

    if [[ hcode -ne 200 ]]; then
      echo '!!!! failed to include git-completion !!!!!'
      return
    fi
    GIT_COMPLETION_PATH="${HOME}/git-completion.bash"
    curl -sS ${gitcomp_url} >$GIT_COMPLETION_PATH
  fi
  source ${GIT_COMPLETION_PATH}
}

# イラネーな
# enable-git-completion

install-manpages-ja() {
  read -p 'change locale to JP, ok? (y)' input
  test "$input" != "y" && return 1

  # by JM Project
  sudo apt update
  sudo apt install manpages-ja
  sudo apt install manpages-ja-dev
  sudo apt install language-pack-ja
  sudo update-locale LANG=ja_JP.utf8
  locale
  sleep 4
  exec $SHELL -l
  # export LC_ALL=ja_JP.utf8
  # export LANGUAGE=ja_JP.utf8
}

install-docker-compose-v1() {
  sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
  sudo chmod +x /usr/local/bin/docker-compose
}

install-awscliv2() {
  if [ "$(which unzip)" = '' ]; then
    test -f /etc/redhat-release/ && sudo dnf install -y unzip
    test -f /etc/system-release/ && sudo yum install -y unzip
    test -f /etc/debian-release/ && sudo apt install -y unzip
  fi

  curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
  unzip awscliv2.zip
  sudo ./aws/install
  rm awscliv2.zip && rm -rf aws/
  aws --version
  # aws cli v2 completion
}

test -f '/usr/local/bin/aws_completer' && complete -C '/usr/local/bin/aws_completer' aws

# ============================================================

# read -p "Hit enter: "
setup-awscliv2() {
  csv=${1:-credentials.csv}

  while :; do
    read -p "import csv? ([y/n/[a]bort): " key
    case "$key" in
    [aA]*)
      echo 'abort.'
      break
      ;;
    [yY] | [yY]es)
      # credentials accessKey csv でのIAMユーザー追加
      aws configure set region ap-northeast-1
      aws configure import --csv file://${csv}
      break
      ;;
    [nN]*)
      # 手動セットアップ
      aws configure set region ap-northeast-1
      aws configure
      # リージョン情報セット ~/.aws/config に保存
      break
      ;;
    *) ;;
    esac
  done
  echo 'set following env...'
  echo 'export AWS_PROFILE=<your profile name>'
  echo 'export AWS_DEFAULT_REGION=<region  ex. ap-northeast-1>'
}

if is_wsl; then
  test -r ~/.bashrc_wsl && . ~/.bashrc_wsl
elif is_linux; then
  test -r ~/.bashrc_linux && . ~/.bashrc_linux
elif is_mac; then
  :
else
  exit 1
fi

# ============= PS1 sample ===============
# if [ -f /etc/bash_completion.d/git-prompt.sh ];then
#     PS1='\e[30;47m \t \e[30;44m\e[30;37m \W $(__git_ps1 "\e[30;47m(%s)")\e[39;49m <`git config user.name`> \e[0m\n\$ '
# else
#     PS1='\e[30;47m \t \e[30;44m\e[30;37m \W \e[0m we need git! \n\$ '
# fi

# ============= to .bashrc ===============
# test -r ~/.bashrc_user && . ~/.bashrc_user

test -r ~/.bash_aliases && . ~/.bash_aliases
test -r ~/.bashrc.local && . ~/.bashrc.local
